<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Love Chess Game - Playing with My Heart</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Georgia', serif;
            background: linear-gradient(135deg, #ff6b6b, #ff8e8e, #ffa8a8);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .game-container {
            display: flex;
            gap: 20px;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
            max-width: 1200px;
            width: 100%;
        }

        .chess-board-container {
            flex: 2;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .game-info {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .chess-board {
            width: 500px;
            height: 500px;
            border: 4px solid #8B4513;
            border-radius: 10px;
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        .square {
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 32px;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
        }

        .square.light {
            background-color: #F0D9B5;
        }

        .square.dark {
            background-color: #B58863;
        }

        .square.selected {
            background-color: #FFD700 !important;
            box-shadow: inset 0 0 10px rgba(255, 215, 0, 0.8);
        }

        .square.possible-move {
            position: relative;
        }

        .square.possible-move::after {
            content: '';
            position: absolute;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background-color: rgba(0, 255, 0, 0.6);
            pointer-events: none;
            z-index: 10;
        }

        .square.possible-move.has-piece::after {
            width: 100%;
            height: 100%;
            border-radius: 0;
            background-color: rgba(255, 0, 0, 0.4);
            border: 3px solid #ff0000;
        }

        .square.check {
            background-color: #FF6B6B !important;
            animation: checkBlink 1s infinite;
        }

        @keyframes checkBlink {

            0%,
            50% {
                background-color: #FF6B6B;
            }

            51%,
            100% {
                background-color: #FF4444;
            }
        }

        .square:hover {
            transform: scale(1.02);
            z-index: 5;
        }

        .piece {
            font-size: 36px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
            transition: all 0.3s;
            z-index: 10;
            position: relative;
        }

        .piece:hover {
            transform: scale(1.1);
        }

        .player-info {
            background: linear-gradient(45deg, #ff6b6b, #ff8e8e);
            color: white;
            padding: 15px;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            margin: 10px 0;
        }

        .player-info h3 {
            margin-bottom: 10px;
            font-size: 1.2em;
        }

        .player-info.active {
            background: linear-gradient(45deg, #28a745, #20c997);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.02);
            }

            100% {
                transform: scale(1);
            }
        }

        .captured-pieces {
            background: rgba(255, 182, 193, 0.2);
            padding: 15px;
            border-radius: 15px;
            border: 2px solid #ff6b6b;
        }

        .captured-pieces h4 {
            color: #d63384;
            margin-bottom: 10px;
            text-align: center;
        }

        .captured-list {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            justify-content: center;
            min-height: 40px;
        }

        .captured-piece {
            font-size: 24px;
            opacity: 0.7;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
        }

        .move-history {
            background: rgba(255, 182, 193, 0.2);
            padding: 15px;
            border-radius: 15px;
            border: 2px solid #ff6b6b;
            max-height: 200px;
            overflow-y: auto;
        }

        .move-history h4 {
            color: #d63384;
            margin-bottom: 10px;
            text-align: center;
        }

        .move-item {
            padding: 5px;
            margin: 2px 0;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 5px;
            font-size: 14px;
            color: #495057;
        }

        .love-message-display {
            background: linear-gradient(45deg, #ff6b6b, #ff8e8e);
            color: white;
            padding: 20px;
            border-radius: 15px;
            text-align: center;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.2);
            animation: loveGlow 3s ease-in-out infinite alternate;
        }

        @keyframes loveGlow {
            0% {
                box-shadow: 0 5px 15px rgba(255, 107, 107, 0.3);
            }

            100% {
                box-shadow: 0 5px 30px rgba(255, 107, 107, 0.6);
            }
        }

        .game-status {
            background: rgba(255, 182, 193, 0.2);
            padding: 15px;
            border-radius: 15px;
            text-align: center;
            border: 2px solid #ff6b6b;
        }

        .game-status h3 {
            color: #d63384;
            margin-bottom: 10px;
        }

        .status-text {
            font-size: 16px;
            color: #495057;
            font-weight: bold;
        }

        .game-controls {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 10px;
        }

        .btn {
            background: linear-gradient(45deg, #ff6b6b, #ff8e8e);
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 15px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255, 107, 107, 0.4);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .coordinates {
            position: absolute;
            font-size: 10px;
            color: #666;
            font-weight: bold;
            pointer-events: none;
        }

        .coord-letter {
            bottom: 2px;
            right: 2px;
        }

        .coord-number {
            top: 2px;
            left: 2px;
        }

        .floating-hearts {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1000;
        }

        .floating-heart {
            position: absolute;
            font-size: 24px;
            color: #ff6b6b;
            animation: floatUp 3s ease-out forwards;
        }

        @keyframes floatUp {
            0% {
                opacity: 1;
                transform: translateY(0) scale(1);
            }

            100% {
                opacity: 0;
                transform: translateY(-100px) scale(1.5);
            }
        }

        .game-winner {
            background: linear-gradient(45deg, #28a745, #20c997);
            color: white;
            padding: 20px;
            border-radius: 15px;
            text-align: center;
            font-size: 20px;
            font-weight: bold;
            animation: celebrate 2s ease-in-out infinite alternate;
        }

        @keyframes celebrate {
            0% {
                transform: scale(1);
            }

            100% {
                transform: scale(1.05);
            }
        }

        .audio-controls {
            text-align: center;
            margin-top: 10px;
        }

        .audio-toggle {
            background: rgba(255, 107, 107, 0.2);
            border: 2px solid #ff6b6b;
            color: #d63384;
            padding: 5px 10px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 12px;
        }

        .audio-toggle:hover {
            background: #ff6b6b;
            color: white;
        }

        @media (max-width: 768px) {
            .game-container {
                flex-direction: column;
                padding: 10px;
            }

            .chess-board {
                width: 100%;
                max-width: 400px;
                height: auto;
                aspect-ratio: 1;
            }

            .piece {
                font-size: 28px;
            }
        }
    </style>
</head>

<body>
    <div class="floating-hearts" id="floatingHearts"></div>

    <div class="game-container">
        <div class="chess-board-container">
            <div class="player-info" id="opponentInfo">
                <h3>Player 2 (Black)</h3>
                <div class="status-text">ðŸ’•</div>
            </div>

            <div class="chess-board" id="chessBoard"></div>

            <div class="player-info active" id="playerInfo">
                <h3>Player 1 (White)</h3>
                <div class="status-text">ðŸ’–</div>
            </div>

            <div class="audio-controls">
                <button class="audio-toggle" id="audioToggle">ðŸ”Š Audio: ON</button>
            </div>
        </div>

        <div class="game-info">
            <div class="love-message-display" id="loveMessage">
                Welcome to our love chess game! White moves first. ðŸ’•
            </div>

            <div class="game-status" id="gameStatus">
                <h3>Game Status</h3>
                <div class="status-text">White's turn</div>
            </div>

            <div class="captured-pieces">
                <h4>White Captured ðŸ‘‘</h4>
                <div class="captured-list" id="whiteCaptured"></div>
            </div>

            <div class="captured-pieces">
                <h4>Black Captured ðŸ’”</h4>
                <div class="captured-list" id="blackCaptured"></div>
            </div>

            <div class="move-history">
                <h4>Move History ðŸ“œ</h4>
                <div id="moveHistoryList"></div>
            </div>

            <div class="game-controls">
                <button class="btn" id="newGameBtn">New Game</button>
                <button class="btn" id="undoBtn">Undo Move</button>
            </div>
        </div>
    </div>

    <script>
        // Game state
        let gameState = {
            board: [],
            currentPlayer: 'white',
            gameOver: false,
            winner: null,
            inCheck: { white: false, black: false },
            capturedPieces: { white: [], black: [] },
            moveHistory: [],
            enPassantTarget: null,
            castlingRights: {
                white: { kingside: true, queenside: true },
                black: { kingside: true, queenside: true }
            }
        };

        let selectedSquare = null;
        let possibleMoves = [];
        let audioEnabled = true;

        // Chess piece Unicode characters
        const pieceSymbols = {
            'white': {
                'king': 'â™”', 'queen': 'â™•', 'rook': 'â™–',
                'bishop': 'â™—', 'knight': 'â™˜', 'pawn': 'â™™'
            },
            'black': {
                'king': 'â™š', 'queen': 'â™›', 'rook': 'â™œ',
                'bishop': 'â™', 'knight': 'â™ž', 'pawn': 'â™Ÿ'
            }
        };

        // Love messages for moves
        const loveMessages = [
            "Beautiful move, darling! ðŸ’•",
            "Your strategy melts my heart! ðŸ’–",
            "Playing with you is pure magic! âœ¨",
            "Every move you make, I love more! ðŸ’—",
            "You're as brilliant as you are beautiful! ðŸŒŸ",
            "This game is our love story! ðŸ’",
            "Your intelligence is so attractive! ðŸ§ ðŸ’•",
            "Playing chess with you is heavenly! ðŸ˜‡",
            "You make my heart skip a beat! ðŸ’“",
            "Love is in the air... and on the board! ðŸ’ž"
        ];

        // Initialize game
        function initializeGame() {
            setupInitialBoard();
            createChessBoard();
            updateDisplay();
        }

        // Setup initial chess board
        function setupInitialBoard() {
            // Initialize empty board
            gameState.board = Array(8).fill().map(() => Array(8).fill(null));

            // Place pieces
            const initialSetup = [
                ['rook', 'knight', 'bishop', 'queen', 'king', 'bishop', 'knight', 'rook'],
                ['pawn', 'pawn', 'pawn', 'pawn', 'pawn', 'pawn', 'pawn', 'pawn']
            ];

            // Black pieces
            for (let col = 0; col < 8; col++) {
                gameState.board[0][col] = { type: initialSetup[0][col], color: 'black' };
                gameState.board[1][col] = { type: initialSetup[1][col], color: 'black' };
            }

            // White pieces
            for (let col = 0; col < 8; col++) {
                gameState.board[7][col] = { type: initialSetup[0][col], color: 'white' };
                gameState.board[6][col] = { type: initialSetup[1][col], color: 'white' };
            }
        }

        // Create chess board DOM
        function createChessBoard() {
            const board = document.getElementById('chessBoard');
            board.innerHTML = '';

            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const square = document.createElement('div');
                    square.className = `square ${(row + col) % 2 === 0 ? 'light' : 'dark'}`;
                    square.dataset.row = row;
                    square.dataset.col = col;

                    // Add coordinates
                    const coordLetter = document.createElement('div');
                    coordLetter.className = 'coordinates coord-letter';
                    coordLetter.textContent = String.fromCharCode(97 + col);

                    const coordNumber = document.createElement('div');
                    coordNumber.className = 'coordinates coord-number';
                    coordNumber.textContent = 8 - row;

                    square.appendChild(coordLetter);
                    square.appendChild(coordNumber);

                    square.addEventListener('click', handleSquareClick);
                    board.appendChild(square);
                }
            }
        }

        // Handle square clicks
        function handleSquareClick(event) {
            if (gameState.gameOver) return;

            const square = event.currentTarget;
            const row = parseInt(square.dataset.row);
            const col = parseInt(square.dataset.col);

            if (selectedSquare) {
                // Try to make move
                if (selectedSquare.row === row && selectedSquare.col === col) {
                    // Deselect current square
                    clearSelection();
                } else {
                    // Check if this is a valid move
                    const isValidMove = possibleMoves.some(move => move.row === row && move.col === col);
                    if (isValidMove) {
                        makeMove(selectedSquare.row, selectedSquare.col, row, col);
                    }
                    clearSelection();
                }
            } else {
                // Select square
                const piece = gameState.board[row][col];
                if (piece && piece.color === gameState.currentPlayer) {
                    selectSquare(row, col);
                }
            }
        }

        // Select square and show possible moves
        function selectSquare(row, col) {
            clearSelection();
            selectedSquare = { row, col };

            const square = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
            square.classList.add('selected');

            // Get and highlight possible moves
            possibleMoves = getValidMoves(row, col);
            possibleMoves.forEach(move => {
                const moveSquare = document.querySelector(`[data-row="${move.row}"][data-col="${move.col}"]`);
                moveSquare.classList.add('possible-move');

                // Add different styling for capture moves
                if (gameState.board[move.row][move.col]) {
                    moveSquare.classList.add('has-piece');
                }
            });
        }

        // Clear selection and highlights
        function clearSelection() {
            document.querySelectorAll('.square').forEach(square => {
                square.classList.remove('selected', 'possible-move', 'has-piece');
            });
            selectedSquare = null;
            possibleMoves = [];
        }

        // Get valid moves for a piece
        function getValidMoves(row, col) {
            const piece = gameState.board[row][col];
            if (!piece) return [];

            let moves = [];

            switch (piece.type) {
                case 'pawn':
                    moves = getPawnMoves(row, col, piece.color);
                    break;
                case 'rook':
                    moves = getRookMoves(row, col, piece.color);
                    break;
                case 'knight':
                    moves = getKnightMoves(row, col, piece.color);
                    break;
                case 'bishop':
                    moves = getBishopMoves(row, col, piece.color);
                    break;
                case 'queen':
                    moves = getQueenMoves(row, col, piece.color);
                    break;
                case 'king':
                    moves = getKingMoves(row, col, piece.color);
                    break;
            }

            // Filter out moves that would put own king in check
            return moves.filter(move => !wouldBeInCheck(row, col, move.row, move.col, piece.color));
        }

        // Pawn moves
        function getPawnMoves(row, col, color) {
            const moves = [];
            const direction = color === 'white' ? -1 : 1;
            const startRow = color === 'white' ? 6 : 1;

            // Forward move
            if (row + direction >= 0 && row + direction < 8 && !gameState.board[row + direction][col]) {
                moves.push({ row: row + direction, col });

                // Double move from starting position
                if (row === startRow && !gameState.board[row + 2 * direction][col]) {
                    moves.push({ row: row + 2 * direction, col });
                }
            }

            // Captures
            for (let colOffset of [-1, 1]) {
                const newCol = col + colOffset;
                if (newCol >= 0 && newCol < 8 && row + direction >= 0 && row + direction < 8) {
                    const target = gameState.board[row + direction][newCol];
                    if (target && target.color !== color) {
                        moves.push({ row: row + direction, col: newCol });
                    }
                }
            }

            return moves;
        }

        // Rook moves
        function getRookMoves(row, col, color) {
            const moves = [];
            const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];

            for (let [dRow, dCol] of directions) {
                for (let i = 1; i < 8; i++) {
                    const newRow = row + i * dRow;
                    const newCol = col + i * dCol;

                    if (newRow < 0 || newRow >= 8 || newCol < 0 || newCol >= 8) break;

                    const target = gameState.board[newRow][newCol];
                    if (!target) {
                        moves.push({ row: newRow, col: newCol });
                    } else {
                        if (target.color !== color) {
                            moves.push({ row: newRow, col: newCol });
                        }
                        break;
                    }
                }
            }

            return moves;
        }

        // Knight moves
        function getKnightMoves(row, col, color) {
            const moves = [];
            const knightMoves = [
                [-2, -1], [-2, 1], [-1, -2], [-1, 2],
                [1, -2], [1, 2], [2, -1], [2, 1]
            ];

            for (let [dRow, dCol] of knightMoves) {
                const newRow = row + dRow;
                const newCol = col + dCol;

                if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {
                    const target = gameState.board[newRow][newCol];
                    if (!target || target.color !== color) {
                        moves.push({ row: newRow, col: newCol });
                    }
                }
            }

            return moves;
        }

        // Bishop moves
        function getBishopMoves(row, col, color) {
            const moves = [];
            const directions = [[-1, -1], [-1, 1], [1, -1], [1, 1]];

            for (let [dRow, dCol] of directions) {
                for (let i = 1; i < 8; i++) {
                    const newRow = row + i * dRow;
                    const newCol = col + i * dCol;

                    if (newRow < 0 || newRow >= 8 || newCol < 0 || newCol >= 8) break;

                    const target = gameState.board[newRow][newCol];
                    if (!target) {
                        moves.push({ row: newRow, col: newCol });
                    } else {
                        if (target.color !== color) {
                            moves.push({ row: newRow, col: newCol });
                        }
                        break;
                    }
                }
            }

            return moves;
        }

        // Queen moves
        function getQueenMoves(row, col, color) {
            return [...getRookMoves(row, col, color), ...getBishopMoves(row, col, color)];
        }

        // King moves
        function getKingMoves(row, col, color) {
            const moves = [];
            const directions = [
                [-1, -1], [-1, 0], [-1, 1],
                [0, -1], [0, 1],
                [1, -1], [1, 0], [1, 1]
            ];

            for (let [dRow, dCol] of directions) {
                const newRow = row + dRow;
                const newCol = col + dCol;

                if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {
                    const target = gameState.board[newRow][newCol];
                    if (!target || target.color !== color) {
                        moves.push({ row: newRow, col: newCol });
                    }
                }
            }

            return moves;
        }

        // Check if move would put own king in check
        function wouldBeInCheck(fromRow, fromCol, toRow, toCol, color) {
            // Make temporary move
            const originalPiece = gameState.board[toRow][toCol];
            const movingPiece = gameState.board[fromRow][fromCol];

            gameState.board[toRow][toCol] = movingPiece;
            gameState.board[fromRow][fromCol] = null;

            // Check if king is in check
            const inCheck = isInCheck(color);

            // Restore original state
            gameState.board[fromRow][fromCol] = movingPiece;
            gameState.board[toRow][toCol] = originalPiece;

            return inCheck;
        }

        // Check if a color is in check
        function isInCheck(color) {
            // Find king position
            let kingRow = -1, kingCol = -1;
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = gameState.board[row][col];
                    if (piece && piece.type === 'king' && piece.color === color) {
                        kingRow = row;
                        kingCol = col;
                        break;
                    }
                }
                if (kingRow !== -1) break;
            }

            if (kingRow === -1) return false;

            // Check if any enemy piece can attack the king
            const enemyColor = color === 'white' ? 'black' : 'white';
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = gameState.board[row][col];
                    if (piece && piece.color === enemyColor) {
                        const moves = getBasicMoves(row, col, piece.type, piece.color);
                        if (moves.some(move => move.row === kingRow && move.col === kingCol)) {
                            return true;
                        }
                    }
                }
            }

            return false;
        }

        // Get basic moves without check validation (to avoid recursion)
        function getBasicMoves(row, col, pieceType, color) {
            switch (pieceType) {
                case 'pawn':
                    return getPawnAttacks(row, col, color);
                case 'rook':
                    return getRookMoves(row, col, color);
                case 'knight':
                    return getKnightMoves(row, col, color);
                case 'bishop':
                    return getBishopMoves(row, col, color);
                case 'queen':
                    return getQueenMoves(row, col, color);
                case 'king':
                    return getKingMoves(row, col, color);
                default:
                    return [];
            }
        }

        // Get pawn attacks (different from pawn moves)
        function getPawnAttacks(row, col, color) {
            const attacks = [];
            const direction = color === 'white' ? -1 : 1;

            for (let colOffset of [-1, 1]) {
                const newCol = col + colOffset;
                if (newCol >= 0 && newCol < 8 && row + direction >= 0 && row + direction < 8) {
                    attacks.push({ row: row + direction, col: newCol });
                }
            }

            return attacks;
        }

        // Make a move
        function makeMove(fromRow, fromCol, toRow, toCol) {
            const piece = gameState.board[fromRow][fromCol];
            const capturedPiece = gameState.board[toRow][toCol];

            // Record move
            const moveNotation = getMoveNotation(fromRow, fromCol, toRow, toCol, piece, capturedPiece);
            gameState.moveHistory.push({
                from: [fromRow, fromCol],
                to: [toRow, toCol],
                piece: piece,
                captured: capturedPiece,
                notation: moveNotation
            });

            // Handle captures
            if (capturedPiece) {
                gameState.capturedPieces[gameState.currentPlayer].push(capturedPiece);
            }

            // Move piece
            gameState.board[toRow][toCol] = piece;
            gameState.board[fromRow][fromCol] = null;

            // Handle pawn promotion
            if (piece.type === 'pawn' && (toRow === 0 || toRow === 7)) {
                gameState.board[toRow][toCol] = { type: 'queen', color: piece.color };
            }

            // Switch turns
            gameState.currentPlayer = gameState.currentPlayer === 'white' ? 'black' : 'white';

            // Update check status
            gameState.inCheck.white = isInCheck('white');
            gameState.inCheck.black = isInCheck('black');

            // Check for checkmate or stalemate
            if (isCheckmate(gameState.currentPlayer)) {
                gameState.gameOver = true;
                gameState.winner = gameState.currentPlayer === 'white' ? 'black' : 'white';
            } else if (isStalemate(gameState.currentPlayer)) {
                gameState.gameOver = true;
                gameState.winner = 'draw';
            }

            // Update display
            updateDisplay();

            // Show love message
            showLoveMessage();

            // Create floating hearts
            createFloatingHeart();
        }

        // Get move notation
        function getMoveNotation(fromRow, fromCol, toRow, toCol, piece, capturedPiece) {
            const fromSquare = String.fromCharCode(97 + fromCol) + (8 - fromRow);
            const toSquare = String.fromCharCode(97 + toCol) + (8 - toRow);
            const pieceSymbol = piece.type === 'pawn' ? '' : piece.type.toUpperCase();
            const captureSymbol = capturedPiece ? 'x' : '';

            return `${pieceSymbol}${fromSquare}${captureSymbol}${toSquare}`;
        }

        // Check for checkmate
        function isCheckmate(color) {
            if (!isInCheck(color)) return false;

            // Check if any piece can make a legal move
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = gameState.board[row][col];
                    if (piece && piece.color === color) {
                        const moves = getValidMoves(row, col);
                        if (moves.length > 0) {
                            return false;
                        }
                    }
                }
            }

            return true;
        }

        // Check for stalemate
        function isStalemate(color) {
            if (isInCheck(color)) return false;

            // Check if any piece can make a legal move
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = gameState.board[row][col];
                    if (piece && piece.color === color) {
                        const moves = getValidMoves(row, col);
                        if (moves.length > 0) {
                            return false;
                        }
                    }
                }
            }

            return true;
        }

        // Update all display elements
        function updateDisplay() {
            updateBoard();
            updateGameInfo();
            updateCapturedPieces();
            updateMoveHistory();
        }

        // Update board display
        function updateBoard() {
            const board = document.getElementById('chessBoard');
            const squares = board.querySelectorAll('.square');

            squares.forEach(square => {
                const row = parseInt(square.dataset.row);
                const col = parseInt(square.dataset.col);
                const piece = gameState.board[row][col];

                // Clear previous piece
                const existingPiece = square.querySelector('.piece');
                if (existingPiece) {
                    existingPiece.remove();
                }

                // Add new piece
                if (piece) {
                    const pieceElement = document.createElement('div');
                    pieceElement.className = 'piece';
                    pieceElement.textContent = pieceSymbols[piece.color][piece.type];
                    square.appendChild(pieceElement);
                }

                // Highlight check
                square.classList.remove('check');
                if (piece && piece.type === 'king') {
                    if ((piece.color === 'white' && gameState.inCheck.white) ||
                        (piece.color === 'black' && gameState.inCheck.black)) {
                        square.classList.add('check');
                    }
                }
            });
        }

        // Update game info
        function updateGameInfo() {
            const gameStatus = document.getElementById('gameStatus');
            const statusText = gameStatus.querySelector('.status-text');
            const playerInfo = document.getElementById('playerInfo');
            const opponentInfo = document.getElementById('opponentInfo');

            // Update player info
            playerInfo.classList.remove('active');
            opponentInfo.classList.remove('active');

            if (gameState.gameOver) {
                if (gameState.winner === 'draw') {
                    statusText.textContent = 'Game ended in a draw! ðŸ’•';
                    gameStatus.className = 'game-status';
                } else {
                    statusText.textContent = `${gameState.winner === 'white' ? 'White' : 'Black'} wins! ðŸŽ‰`;
                    gameStatus.className = 'game-winner';
                }
            } else {
                const currentPlayerName = gameState.currentPlayer === 'white' ? 'White' : 'Black';
                statusText.textContent = `${currentPlayerName}'s turn`;
                gameStatus.className = 'game-status';

                if (gameState.currentPlayer === 'white') {
                    playerInfo.classList.add('active');
                } else {
                    opponentInfo.classList.add('active');
                }

                // Add check indicator
                if (gameState.inCheck[gameState.currentPlayer]) {
                    statusText.textContent += ' (In Check!)';
                }
            }
        }

        // Update captured pieces
        function updateCapturedPieces() {
            const whiteCaptured = document.getElementById('whiteCaptured');
            const blackCaptured = document.getElementById('blackCaptured');

            whiteCaptured.innerHTML = '';
            blackCaptured.innerHTML = '';

            // White's captured pieces
            gameState.capturedPieces.white.forEach(piece => {
                const pieceElement = document.createElement('div');
                pieceElement.className = 'captured-piece';
                pieceElement.textContent = pieceSymbols[piece.color][piece.type];
                whiteCaptured.appendChild(pieceElement);
            });

            // Black's captured pieces
            gameState.capturedPieces.black.forEach(piece => {
                const pieceElement = document.createElement('div');
                pieceElement.className = 'captured-piece';
                pieceElement.textContent = pieceSymbols[piece.color][piece.type];
                blackCaptured.appendChild(pieceElement);
            });
        }

        // Update move history
        function updateMoveHistory() {
            const moveHistoryList = document.getElementById('moveHistoryList');
            moveHistoryList.innerHTML = '';

            gameState.moveHistory.forEach((move, index) => {
                const moveElement = document.createElement('div');
                moveElement.className = 'move-item';

                const piece = pieceSymbols[move.piece.color][move.piece.type];
                const moveNumber = Math.floor(index / 2) + 1;
                const playerColor = move.piece.color;

                moveElement.textContent = `${moveNumber}${playerColor === 'white' ? '.' : '...'} ${piece} ${move.notation}`;
                moveHistoryList.appendChild(moveElement);
            });

            // Scroll to bottom
            moveHistoryList.scrollTop = moveHistoryList.scrollHeight;
        }

        // Show love message
        function showLoveMessage() {
            const loveMessage = document.getElementById('loveMessage');
            const randomMessage = loveMessages[Math.floor(Math.random() * loveMessages.length)];

            loveMessage.textContent = randomMessage;

            // Speak love message
            if (audioEnabled) {
                speakLoveMessage(randomMessage);
            }
        }

        // Speak love message
        function speakLoveMessage(message) {
            if (!audioEnabled || !('speechSynthesis' in window)) return;

            const utterance = new SpeechSynthesisUtterance(message);
            utterance.rate = 0.8;
            utterance.pitch = 1.2;
            utterance.volume = 0.8;

            // Try to use a female voice
            const voices = speechSynthesis.getVoices();
            const femaleVoice = voices.find(voice =>
                voice.name.includes('Female') ||
                voice.name.includes('woman') ||
                voice.name.includes('Samantha') ||
                voice.name.includes('Zira')
            );

            if (femaleVoice) {
                utterance.voice = femaleVoice;
            }

            speechSynthesis.speak(utterance);
        }

        // Create floating hearts
        function createFloatingHeart() {
            const hearts = ['ðŸ’•', 'ðŸ’–', 'ðŸ’—', 'ðŸ’', 'ðŸ’ž', 'ðŸ’“', 'ðŸ’˜'];
            const heart = document.createElement('div');
            heart.className = 'floating-heart';
            heart.textContent = hearts[Math.floor(Math.random() * hearts.length)];
            heart.style.left = Math.random() * window.innerWidth + 'px';
            heart.style.top = window.innerHeight + 'px';

            document.getElementById('floatingHearts').appendChild(heart);

            setTimeout(() => {
                heart.remove();
            }, 3000);
        }

        // Undo last move
        function undoMove() {
            if (gameState.moveHistory.length === 0 || gameState.gameOver) return;

            const lastMove = gameState.moveHistory.pop();

            // Restore pieces
            gameState.board[lastMove.from[0]][lastMove.from[1]] = lastMove.piece;
            gameState.board[lastMove.to[0]][lastMove.to[1]] = lastMove.captured;

            // Remove from captured pieces if there was a capture
            if (lastMove.captured) {
                const capturedArray = gameState.capturedPieces[lastMove.piece.color];
                const index = capturedArray.findIndex(p =>
                    p.type === lastMove.captured.type && p.color === lastMove.captured.color
                );
                if (index > -1) {
                    capturedArray.splice(index, 1);
                }
            }

            // Handle pawn promotion undo
            if (lastMove.piece.type === 'pawn' &&
                (lastMove.to[0] === 0 || lastMove.to[0] === 7)) {
                gameState.board[lastMove.from[0]][lastMove.from[1]] = lastMove.piece;
            }

            // Switch turns back
            gameState.currentPlayer = gameState.currentPlayer === 'white' ? 'black' : 'white';

            // Reset game over state
            gameState.gameOver = false;
            gameState.winner = null;

            // Update check status
            gameState.inCheck.white = isInCheck('white');
            gameState.inCheck.black = isInCheck('black');

            // Clear selection
            clearSelection();

            // Update display
            updateDisplay();
        }

        // New game
        function newGame() {
            gameState = {
                board: [],
                currentPlayer: 'white',
                gameOver: false,
                winner: null,
                inCheck: { white: false, black: false },
                capturedPieces: { white: [], black: [] },
                moveHistory: [],
                enPassantTarget: null,
                castlingRights: {
                    white: { kingside: true, queenside: true },
                    black: { kingside: true, queenside: true }
                }
            };

            clearSelection();
            setupInitialBoard();
            updateDisplay();

            document.getElementById('loveMessage').textContent =
                'Welcome to our love chess game! White moves first. ðŸ’•';
        }

        // Event listeners
        document.getElementById('audioToggle').addEventListener('click', function () {
            audioEnabled = !audioEnabled;
            this.textContent = audioEnabled ? 'ðŸ”Š Audio: ON' : 'ðŸ”‡ Audio: OFF';
        });

        document.getElementById('newGameBtn').addEventListener('click', newGame);
        document.getElementById('undoBtn').addEventListener('click', undoMove);

        // Initialize game when page loads
        document.addEventListener('DOMContentLoaded', function () {
            // Load voices for speech synthesis
            if ('speechSynthesis' in window) {
                speechSynthesis.getVoices();
                speechSynthesis.onvoiceschanged = function () {
                    speechSynthesis.getVoices();
                };
            }

            initializeGame();
        });
    </script>
</body>

</html>